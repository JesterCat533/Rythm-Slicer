<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhythm Slicer</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js for sound effects - Updated to a more recent stable version -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dark background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            color: #e6edf3;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #game-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #161b22; /* Slightly lighter dark for container */
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 255, 255, 0.2), 0 5px 15px rgba(255, 0, 255, 0.2);
            padding: 20px;
            max-width: 90vw;
            width: 800px; /* Base width for the game area */
            box-sizing: border-box;
            border: 2px solid rgba(0, 255, 255, 0.4);
            overflow: hidden;
        }

        canvas {
            background-color: #0d1117;
            display: block;
            border-radius: 15px;
            box-shadow: inset 0 0 15px rgba(0, 255, 255, 0.1);
            width: 100%; /* Make canvas responsive within its container */
            height: auto; /* Maintain aspect ratio */
            border: 1px solid rgba(0, 255, 255, 0.2);
        }

        #game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 15px;
            padding: 0 10px;
            box-sizing: border-box;
            align-items: center;
        }

        #score, #health-bar-container, #combo-display, #accuracy-display {
            font-size: 1.5rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #health-bar-outer {
            width: 200px;
            height: 25px;
            background-color: #30363d;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(255, 0, 255, 0.4);
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.2);
        }

        #health-bar-inner {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff007f, #ffcc00); /* Vibrant gradient */
            border-radius: 12px;
            transition: width 0.1s ease-out;
        }

        #combo-display {
            color: #00ffcc; /* Greenish-cyan for combo */
            font-size: 2rem;
            text-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
            min-width: 80px; /* To prevent layout shift */
            text-align: center;
        }
        #combo-display.pulsate-combo {
            animation: comboPulse 0.3s ease-out forwards;
        }

        @keyframes comboPulse {
            0% { transform: scale(1); text-shadow: 0 0 10px rgba(0, 255, 204, 0.5); }
            50% { transform: scale(1.15); text-shadow: 0 0 20px rgba(0, 255, 204, 0.8); }
            100% { transform: scale(1); text-shadow: 0 0 10px rgba(0, 255, 204, 0.5); }
        }

        #accuracy-display {
            position: absolute;
            bottom: 20px; /* Position at the bottom of the container */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.6);
            padding: 8px 15px;
            border-radius: 10px;
            color: #ffcc00;
            font-size: 1.3rem;
            font-weight: bold;
            border: 1px solid rgba(255, 204, 0, 0.3);
            box-shadow: 0 0 15px rgba(255, 204, 0, 0.2);
            z-index: 50; /* Above canvas, below modals */
        }


        #game-over-screen, #start-screen, #settings-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            border-radius: 20px;
            z-index: 100;
            backdrop-filter: blur(5px); /* Frosted glass effect */
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        #start-screen h1, #game-over-screen h2 {
            font-size: 3rem;
            color: #00ffff;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
            margin-bottom: 20px;
        }

        #game-over-screen p {
            font-size: 1.8rem;
            margin-top: 15px;
            color: #ffcc00;
        }

        .btn {
            background: linear-gradient(145deg, #00ffff, #007bff);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            font-size: 1.2rem;
            cursor: pointer;
            margin: 10px;
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.3);
            transition: all 0.3s ease;
            font-weight: bold;
            position: relative;
            overflow: hidden;
            outline: none;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300%;
            height: 300%;
            background: rgba(255, 255, 255, 0.15);
            transition: all 0.75s;
            border-radius: 50%;
            z-index: 0;
            transform: translate(-50%, -50%) scale(0);
        }

        .btn:hover::before {
            transform: translate(-50%, -50%) scale(1);
            opacity: 0;
        }

        .btn:hover {
            box-shadow: 0 8px 20px rgba(0, 255, 255, 0.5), 0 0 30px rgba(0, 255, 255, 0.7);
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(1px);
            box-shadow: 0 3px 10px rgba(0, 255, 255, 0.3);
        }

        .settings-btn {
            background: none;
            border: none;
            font-size: 1.8rem;
            color: #00ffff;
            cursor: pointer;
            margin-left: 20px;
            transition: color 0.3s ease;
        }

        .settings-btn:hover {
            color: #ffcc00;
        }

        .modal-content {
            background-color: #1e242c;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 255, 255, 0.3);
            width: 90%;
            max-width: 500px;
            box-sizing: border-box;
            border: 1px solid rgba(0, 255, 255, 0.3);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .modal-content h3 {
            font-size: 2rem;
            color: #00ffff;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
        }

        .modal-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.1rem;
            padding: 10px 0;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.2);
        }

        .modal-item:last-child {
            border-bottom: none;
        }

        .key-display {
            background-color: #30363d;
            padding: 8px 15px;
            border-radius: 8px;
            border: 1px solid rgba(0, 255, 255, 0.2);
            min-width: 60px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .key-display:hover {
            background-color: #404c5a;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 40px;
            height: 40px;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            border-radius: 10px;
            overflow: hidden;
            transition: all 0.2s ease;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: 2px solid #fff;
            border-radius: 8px;
        }

        input[type="color"]:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.4);
        }

        input[type="number"] {
            background-color: #30363d;
            color: #e6edf3;
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 8px;
            padding: 8px 12px;
            width: 80px;
            text-align: center;
            transition: all 0.2s ease;
            -moz-appearance: textfield; /* Hide arrows for Firefox */
        }
        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type="number"]:focus {
            outline: none;
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
        }

        .close-btn {
            background: linear-gradient(145deg, #ff007f, #ff4d00);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 3px 10px rgba(255, 0, 127, 0.3);
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            box-shadow: 0 5px 15px rgba(255, 0, 127, 0.5);
            transform: translateY(-1px);
        }

        .pulsating-element {
            animation: pulse 1.5s infinite alternate;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.05); opacity: 0.9; }
        }

        /* Settings Modal Specifics */
        .settings-nav {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
            padding-bottom: 10px;
        }

        .settings-nav button {
            background: none;
            border: none;
            color: #e6edf3;
            font-size: 1.2rem;
            padding: 8px 15px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
            margin: 0 5px;
        }

        .settings-nav button:hover {
            background-color: rgba(0, 255, 255, 0.1);
        }

        .settings-nav button.active {
            background-color: #00ffff;
            color: #161b22;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .settings-section {
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 15px;
        }
        .settings-section.active {
            display: flex; /* Show active section */
        }

        /* Leaderboard Specifics */
        #leaderboard-section {
            background-color: #1e242c;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.3);
            width: 90%;
            max-width: 400px;
            margin-top: 25px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            animation: fadeIn 0.5s ease-out;
        }

        #leaderboard-section h3 {
            font-size: 1.8rem;
            color: #00ffff;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
            text-align: center;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: linear-gradient(90deg, rgba(255, 0, 127, 0.1), rgba(0, 255, 255, 0.1));
            border-radius: 8px;
            margin-bottom: 8px;
            font-size: 1.1rem;
            border: 1px solid rgba(0, 255, 255, 0.2);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .leaderboard-entry:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 255, 255, 0.4);
        }

        .leaderboard-entry span:first-child {
            font-weight: bold;
            color: #ffcc00;
        }
        .leaderboard-entry span:last-child {
            color: #00ffcc;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-info">
            <div id="score">Score: 0</div>
            <div id="combo-display">0x</div>
            <div id="health-bar-container">
                Health:
                <div id="health-bar-outer">
                    <div id="health-bar-inner"></div>
                </div>
            </div>
            <div>
                <button id="settings-btn" class="settings-btn" title="Settings">⚙️</button>
            </div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="accuracy-display">Accuracy: 100.00%</div>


        <div id="start-screen" class="pulsating-element">
            <h1>Rhythm Slicer</h1>
            <button id="start-game-btn" class="btn">Start Game</button>
        </div>

        <div id="game-over-screen" style="display: none;">
            <h2>Game Over!</h2>
            <p id="final-score">Final Score: 0</p>
            <p id="final-accuracy">Final Accuracy: 0.00%</p>
            <button id="restart-game-btn" class="btn">Restart</button>
            <div id="leaderboard-section">
                <h3>Leaderboard</h3>
                <div id="leaderboard-list">
                    <!-- Leaderboard entries will be dynamically inserted here -->
                </div>
            </div>
        </div>

        <div id="settings-modal" style="display: none;">
            <div class="modal-content">
                <h3>Game Settings</h3>
                <div class="settings-nav">
                    <button id="nav-controls" class="active">Controls & Appearance</button>
                    <button id="nav-gameplay">Gameplay & Audio</button>
                    <button id="nav-account">Account</button> <!-- New Account Tab -->
                </div>

                <div id="section-controls" class="settings-section active">
                    <div class="modal-item">
                        <span>Left Block Key:</span>
                        <span id="left-key-display" class="key-display">U</span>
                    </div>
                    <div class="modal-item">
                        <span>Right Block Key:</span>
                        <span id="right-key-display" class="key-display">O</span>
                    </div>
                    <div class="modal-item">
                        <span>Left Block Color:</span>
                        <input type="color" id="left-color-picker">
                    </div>
                    <div class="modal-item">
                        <span>Right Block Color:</span>
                        <input type="color" id="right-color-picker">
                    </div>
                </div>

                <div id="section-gameplay" class="settings-section">
                    <div class="modal-item">
                        <span>Note Jump Speed (NJS):</span>
                        <input type="number" id="njs-input" value="10" min="1" max="20">
                    </div>
                    <div class="modal-item">
                        <span>Music URL (MP3/WAV):</span>
                        <input type="text" id="music-url-input" placeholder="Paste direct audio URL here" class="flex-grow bg-gray-700 text-white p-2 rounded-lg border border-gray-600 focus:border-blue-500 focus:outline-none">
                    </div>
                    <button id="play-music-btn" class="btn">Play Music</button>
                </div>

                <!-- New Account Settings Section -->
                <div id="section-account" class="settings-section">
                    <p class="text-center text-lg text-gray-300">Login to keep your scores permanently!</p>
                    <button id="login-btn" class="btn">Login / Register</button>
                </div>
                <!-- End New Account Settings Section -->

                <button id="close-settings-btn" class="close-btn">Close</button>
            </div>
        </div>
    </div>
    <audio id="background-music" loop></audio>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const healthBarInner = document.getElementById('health-bar-inner');
        const comboDisplay = document.getElementById('combo-display');
        const accuracyDisplay = document.getElementById('accuracy-display');
        const startScreen = document.getElementById('start-screen');
        const startGameBtn = document.getElementById('start-game-btn');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreDisplay = document.getElementById('final-score');
        const finalAccuracyDisplay = document.getElementById('final-accuracy');
        const restartGameBtn = document.getElementById('restart-game-btn');
        const settingsBtn = document.getElementById('settings-btn');
        const settingsModal = document.getElementById('settings-modal');
        const leftKeyDisplay = document.getElementById('left-key-display');
        const rightKeyDisplay = document.getElementById('right-key-display');
        const leftColorPicker = document.getElementById('left-color-picker');
        const rightColorPicker = document.getElementById('right-color-picker');
        const njsInput = document.getElementById('njs-input');
        const musicUrlInput = document.getElementById('music-url-input');
        const playMusicBtn = document.getElementById('play-music-btn');
        const closeSettingsBtn = document.getElementById('close-settings-btn');
        const backgroundMusic = document.getElementById('background-music');

        // Leaderboard elements
        const leaderboardSection = document.getElementById('leaderboard-section');
        const leaderboardList = document.getElementById('leaderboard-list');


        // Settings Navigation elements
        const navControls = document.getElementById('nav-controls');
        const navGameplay = document.getElementById('nav-gameplay');
        const navAccount = document.getElementById('nav-account'); // New Account tab button
        const sectionControls = document.getElementById('section-controls');
        const sectionGameplay = document.getElementById('section-gameplay');
        const sectionAccount = document.getElementById('section-account'); // New Account section
        const loginBtn = document.getElementById('login-btn'); // Login button in settings


        // Game Constants (adjustable)
        const CANVAS_WIDTH = 760;
        const CANVAS_HEIGHT = 450;
        const TARGET_Y = CANVAS_HEIGHT * 0.85; // Y position where blocks are hit
        const BLOCK_SPAWN_X_LEFT = CANVAS_WIDTH * 0.25;
        const BLOCK_SPWN_X_RIGHT = CANVAS_WIDTH * 0.75;
        const INITIAL_BLOCK_SIZE = 50;
        const BASE_BLOCK_TRAVEL_DURATION = 2000; // Base duration in ms for a block to travel from top to TARGET_Y
        const BASE_HIT_WINDOW_FACTOR = 0.3; // 30% of block's travel duration is the hit window
        const MAX_HEALTH = 100;
        const HEALTH_LOSS_PER_MISS = 15;
        const HEALTH_REGEN_PER_HIT = 5; // Health gained per correct hit
        const PARTICLE_COUNT_ON_HIT = 15;
        const PARTICLE_LIFETIME = 400; // Milliseconds
        const CHAIN_MIN_LENGTH = 2; // Minimum blocks in a chain
        const CHAIN_MAX_LENGTH = 4; // Maximum blocks in a chain
        const CHAIN_OFFSET_TIME = 150; // Time in ms between chain blocks

        const MAX_ACCURACY_POINTS_PER_NOTE = 115; // Max points for a perfect hit
        const MIN_ACCURACY_POINTS_PER_NOTE = 15;  // Min points for a hit at the edge of the window

        const POPUP_LIFETIME = 800; // Milliseconds for popup to fade
        const POPUP_MOVE_SPEED = 0.05; // Pixels per ms

        const CABLE_WIDTH = 8; // Width of the cable connecting double notes
        const CABLE_RADIUS = 4; // Rounded ends for cable

        const HEALTH_LOSS_ON_BOMB_HIT = HEALTH_LOSS_PER_MISS * 2;
        const HEALTH_GAIN_ON_BOMB_MISS = HEALTH_REGEN_PER_HIT * 1.5; // Gain more health for avoiding bombs

        // New spawn probabilities (sum to 1.0)
        const SINGLE_NOTE_CHANCE = 0.40; // Increased to compensate for removed bomb-only spawns
        const DOUBLE_NOTE_CHANCE = 0.20;
        const CHAIN_NOTE_CHANCE = 0.40; // Increased to compensate for removed bomb-only spawns

        // New bomb integration chance for individual notes within single or chain spawns
        const BOMB_INTEGRATION_CHANCE = 0.25; // 25% chance for a single note or chain segment to be a bomb

        // MODIFIED: Wider hit precision window in milliseconds
        const HIT_PRECISION_WINDOW = 200; // Notes must be hit within +/- 100ms of hitTime


        // Game State Variables
        let score = 0;
        let health = MAX_HEALTH;
        let combo = 0;
        let totalNotesHit = 0; // Only counts non-bomb notes that appear
        let totalAccuracySum = 0; // Sum of 0-100 accuracy for each hit
        let blocks = []; // Array to hold active blocks
        let particles = []; // Array to hold active particles
        let popups = []; // Array to hold floating text popups
        let lastBlockSpawnTime = 0;
        let blockSpawnInterval = 1000; // Initial spawn interval
        let gameActive = false;
        let animationFrameId; // For requestAnimationFrame
        let keysPressed = {}; // To track currently held keys
        let gameWasActiveBeforeSettings = false; // To know if game was running before pause
        let doubleNoteCounter = 0; // Unique ID for double notes
        let gameOverHandled = false; // Flag to prevent multiple leaderboard saves on game over


        // Customization
        let keybinds = {
            'left': 'u',
            'right': 'o'
        };
        let blockColors = {
            'left': '#00ffff', // Cyan
            'right': '#ff007f' // Pink
        };
        let awaitingKeybind = null; // 'left' or 'right' if waiting for user input
        let noteJumpSpeed = 10; // NJS: 1-20 (higher is faster)

        // Tone.js Audio Setup
        let kickSynth, hiHatSynth, scratchSynth;
        let synthsInitialized = false; // Global flag to ensure synths are initialized only once

        function setupAudioSynths() {
            // Check if Tone is defined before trying to use it
            if (typeof Tone === 'undefined') {
                console.error("Tone.js is not loaded during setupAudioSynths. This should not happen if called after Tone.start().");
                return;
            }
            if (synthsInitialized) {
                console.log("Audio synths already initialized.");
                return;
            }

            // Kick Drum: Membrane Synth for punchy low end
            kickSynth = new Tone.MembraneSynth({
                pitchDecay: 0.02,
                octaves: 10,
                oscillator: { type: "sine" },
                envelope: {
                    attack: 0.001,
                    decay: 0.4,
                    sustain: 0.01,
                    release: 0.8,
                    attackCurve: "exponential"
                }
            }).toDestination(); // Use .toDestination() for Tone 14.x

            // Hi-Hat: Noise Synth with a high-pass filter
            hiHatSynth = new Tone.NoiseSynth({
                noise: { type: "white" },
                envelope: {
                    attack: 0.001,
                    decay: 0.1,
                    sustain: 0.01,
                    release: 0.05
                },
                filterEnvelope: {
                    attack: 0.001,
                    decay: 0.1,
                    sustain: 0.01,
                    release: 0.05,
                    baseFrequency: 4000,
                    octaves: -2,
                    exponent: 2
                }
            }).toDestination();

            // Scratch Sound: Complex noise/oscillator for jarring effect
            scratchSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator : { type : "sawtooth" },
                envelope : {
                    attack : 0.01,
                    decay : 0.1,
                    sustain : 0.01,
                    release : 0.2
                }
            }).toDestination();

            synthsInitialized = true;
            console.log("Audio synths initialized successfully.");
        }

        // --- Utility Functions ---

        // Function to draw a rounded rectangle
        function roundRect(ctx, x, y, width, height, radius) {
            if (width < 2 * radius) radius = width / 2;
            if (height < 2 * radius) radius = height / 2;
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.arcTo(x + width, y, x + width, y + height, radius);
            ctx.arcTo(x + width, y + height, x, y + height, radius);
            ctx.arcTo(x, y + height, x, y, radius);
            ctx.arcTo(x, y, x + width, y, radius);
            ctx.closePath();
        }

        // Initialize canvas dimensions
        function initCanvas() {
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
        }

        // Function to clamp a value between a min and max
        function clamp(value, min, max) {
            return Math.max(min, Math.min(value, max));
        }

        // --- Game Logic ---

        // Reset game state
        function resetGame() {
            score = 0;
            health = MAX_HEALTH;
            combo = 0;
            totalNotesHit = 0;
            totalAccuracySum = 0;
            blocks = [];
            particles = [];
            popups = [];
            lastBlockSpawnTime = 0;
            blockSpawnInterval = 1000;
            gameActive = true;
            gameOverHandled = false; // Reset the flag
            updateScoreDisplay();
            updateHealthBar();
            updateComboDisplay();
            updateAccuracyDisplay();
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            backgroundMusic.pause();
            backgroundMusic.currentTime = 0;
            gameLoop(performance.now()); // Start the game loop with current timestamp
        }

        // End the game
        function endGame() {
            if (gameOverHandled) return; 
            
            saveScore(score, getOverallAccuracy()); 
            gameOverHandled = true; 

            gameActive = false;
            cancelAnimationFrame(animationFrameId);
            finalScoreDisplay.textContent = `Final Score: ${score}`;
            finalAccuracyDisplay.textContent = `Final Accuracy: ${getOverallAccuracy().toFixed(2)}%`;
            gameOverScreen.style.display = 'flex';
            backgroundMusic.pause();
            displayLeaderboard(); 
            if (typeof Tone !== 'undefined' && Tone.Transport) {
                Tone.Transport.stop();
                Tone.Transport.cancel();
            }
        }

        // Update score display
        function updateScoreDisplay() {
            scoreDisplay.textContent = `Score: ${score}`;
        }

        // Update health bar visual
        function updateHealthBar() {
            healthBarInner.style.width = `${clamp(health, 0, MAX_HEALTH)}%`;
            if (health <= 0) {
                endGame();
            }
        }

        // Update combo display and trigger pulsation
        function updateComboDisplay() {
            comboDisplay.textContent = `${combo}x`;
            comboDisplay.classList.remove('pulsate-combo');
            void comboDisplay.offsetWidth; 
            comboDisplay.classList.add('pulsate-combo');
        }

        // Increment combo
        function incrementCombo() {
            combo++;
            updateComboDisplay();
        }

        // Reset combo
        function resetCombo() {
            if (combo > 0) {
                combo = 0;
                updateComboDisplay();
                if (scratchSynth && typeof Tone !== 'undefined' && Tone.context.state === 'running') {
                    scratchSynth.triggerAttackRelease("C2", "0.2", Tone.now()); 
                }
            }
        }

        // Calculate and update overall accuracy display
        function getOverallAccuracy() {
            if (totalNotesHit === 0) return 100;
            const maxPossibleAccuracySum = totalNotesHit * 100;
            return (totalAccuracySum / maxPossibleAccuracySum) * 100;
        }

        function updateAccuracyDisplay() {
            accuracyDisplay.textContent = `Accuracy: ${getOverallAccuracy().toFixed(2)}%`;
        }

        // Spawn a new block or chain or double note or bomb
        function spawnBlock(timestamp) {
            const blockTravelDuration = BASE_BLOCK_TRAVEL_DURATION / (noteJumpSpeed / 5);
            const startY = -INITIAL_BLOCK_SIZE;

            const spawnTypeRoll = Math.random();
            if (spawnTypeRoll < SINGLE_NOTE_CHANCE) {
                const laneType = Math.random() < 0.5 ? 'left' : 'right';
                const x = laneType === 'left' ? BLOCK_SPAWN_X_LEFT : BLOCK_SPWN_X_RIGHT;
                const isBomb = Math.random() < BOMB_INTEGRATION_CHANCE; 
                blocks.push({
                    x: x,
                    y: startY,
                    size: INITIAL_BLOCK_SIZE,
                    type: laneType,
                    hitTime: timestamp + blockTravelDuration,
                    state: 'incoming',
                    isSlicing: false,
                    sliceProgress: 0,
                    opacity: 1,
                    isChain: false,
                    isDouble: false,
                    isBomb: isBomb, 
                    bombProgress: 0,
                    blockTravelDuration: blockTravelDuration
                });
            } else if (spawnTypeRoll < SINGLE_NOTE_CHANCE + DOUBLE_NOTE_CHANCE) {
                const currentDoubleId = doubleNoteCounter++;
                blocks.push({
                    x: BLOCK_SPAWN_X_LEFT,
                    y: startY,
                    size: INITIAL_BLOCK_SIZE,
                    type: 'left',
                    hitTime: timestamp + blockTravelDuration,
                    state: 'incoming',
                    isSlicing: false,
                    sliceProgress: 0,
                    opacity: 1,
                    isChain: false,
                    isDouble: true,
                    doubleId: currentDoubleId,
                    isBomb: false, 
                    bombProgress: 0,
                    blockTravelDuration: blockTravelDuration
                });
                blocks.push({
                    x: BLOCK_SPWN_X_RIGHT,
                    y: startY,
                    size: INITIAL_BLOCK_SIZE,
                    type: 'right',
                    hitTime: timestamp + blockTravelDuration,
                    state: 'incoming',
                    isSlicing: false,
                    sliceProgress: 0,
                    opacity: 1,
                    isChain: false,
                    isDouble: true,
                    doubleId: currentDoubleId,
                    isBomb: false, 
                    bombProgress: 0,
                    blockTravelDuration: blockTravelDuration
                });
            } else { 
                const laneType = Math.random() < 0.5 ? 'left' : 'right';
                const x = laneType === 'left' ? BLOCK_SPAWN_X_LEFT : BLOCK_SPWN_X_RIGHT;
                const chainLength = Math.floor(Math.random() * (CHAIN_MAX_LENGTH - CHAIN_MIN_LENGTH + 1)) + CHAIN_MIN_LENGTH;
                for (let i = 0; i < chainLength; i++) {
                    const isBomb = Math.random() < BOMB_INTEGRATION_CHANCE; 
                    blocks.push({
                        x: x,
                        y: startY,
                        size: INITIAL_BLOCK_SIZE,
                        type: laneType,
                        hitTime: timestamp + blockTravelDuration + (i * CHAIN_OFFSET_TIME),
                        state: 'incoming',
                        isSlicing: false,
                        sliceProgress: 0,
                        opacity: 1,
                        isChain: true,
                        chainOrder: i,
                        chainLength: chainLength,
                        isDouble: false,
                        isBomb: isBomb, 
                        bombProgress: 0,
                        blockTravelDuration: blockTravelDuration
                    });
                }
            }
        }

        // Update block positions, sizes, and states
        function updateBlocks(deltaTime, currentTime) {
            for (let i = blocks.length - 1; i >= 0; i--) {
                const block = blocks[i];

                if (block.isSlicing) {
                    block.sliceProgress += deltaTime / 150; 
                    block.opacity = 1 - block.sliceProgress;
                    if (block.opacity <= 0) {
                        blocks.splice(i, 1);
                    }
                    continue; 
                }

                const progress = (currentTime - (block.hitTime - block.blockTravelDuration)) / block.blockTravelDuration;
                block.y = -INITIAL_BLOCK_SIZE + (TARGET_Y + INITIAL_BLOCK_SIZE) * progress;

                if (block.isBomb) {
                    const appearanceStartProgress = 0.5; 
                    const appearanceEndProgress = 0.9; 
                    const currentVisualProgress = (block.y - (-INITIAL_BLOCK_SIZE)) / (TARGET_Y + INITIAL_BLOCK_SIZE);
                    block.bombProgress = clamp((currentVisualProgress - appearanceStartProgress) / (appearanceEndProgress - appearanceStartProgress), 0, 1);
                }

                if (block.state === 'incoming') {
                    const missWindowEnd = block.hitTime + HIT_PRECISION_WINDOW / 2; 
                    if (currentTime > missWindowEnd) {
                        if (block.isBomb) {
                            health = clamp(health + HEALTH_GAIN_ON_BOMB_MISS, 0, MAX_HEALTH);
                            updateHealthBar();
                            createParticles(block.x, TARGET_Y, 'health_gain'); 
                            createPopup(block.x, block.y, `+${HEALTH_GAIN_ON_BOMB_MISS} Health!`, '#00ff00'); 
                            block.isSlicing = true;
                            console.log("BOMB MISSED (passed line): Health gained.");
                        } else {
                            health -= HEALTH_LOSS_PER_MISS;
                            updateHealthBar();
                            resetCombo(); 
                            createParticles(block.x, TARGET_Y, 'miss');
                            block.isSlicing = true;
                            if (hiHatSynth && typeof Tone !== 'undefined' && Tone.context.state === 'running') hiHatSynth.triggerAttackRelease("16n", Tone.now() + 0.001); 
                            totalNotesHit++; 
                            updateAccuracyDisplay();
                            console.log("NOTE MISSED (passed line): Health reduced, combo reset.");

                            if (block.isDouble && block.doubleId !== undefined) {
                                const pairedBlock = blocks.find(b => b.doubleId === block.doubleId && b !== block && b.state === 'incoming');
                                if (pairedBlock) {
                                    pairedBlock.isSlicing = true; 
                                    pairedBlock.state = 'missed'; 
                                    totalNotesHit++; 
                                    updateAccuracyDisplay();
                                    console.log("PAIRED DOUBLE NOTE MISSED (passed line).");
                                }
                            }
                        }
                    }
                }
            }
        }

        // Handle key presses for individual hits
        function handleKeyPress(event) {
            if (!gameActive || awaitingKeybind) return;

            const keyPressed = event.key.toLowerCase();
            const currentTime = performance.now(); 
            if (currentTime === null || currentTime === undefined) {
                console.error("Time source returned invalid time, skipping key press handler.");
                return;
            }

            keysPressed[keyPressed] = true;

            let hitOccurredForThisKeyPress = false;
            let processedBlock = null;

            for (let i = blocks.length - 1; i >= 0; i--) {
                const block = blocks[i];
                if (block.state !== 'incoming' || block.isSlicing) continue;

                const hitWindowStart = block.hitTime - HIT_PRECISION_WINDOW / 2;
                const hitWindowEnd = block.hitTime + HIT_PRECISION_WINDOW / 2;

                if (currentTime >= hitWindowStart && currentTime <= hitWindowEnd) {
                    if (block.isBomb) {
                        if (keyPressed === keybinds['left'] || keyPressed === keybinds['right']) {
                            processedBlock = block;
                            break; 
                        }
                    } else { 
                        if ((block.type === 'left' && keyPressed === keybinds['left']) ||
                            (block.type === 'right' && keyPressed === keybinds['right'])) {
                            processedBlock = block;
                            break; 
                        }
                    }
                }
            }

            if (processedBlock) {
                hitOccurredForThisKeyPress = true;
                if (processedBlock.isBomb) {
                    health -= HEALTH_LOSS_ON_BOMB_HIT;
                    updateHealthBar();
                    createParticles(processedBlock.x, processedBlock.y, 'bomb_hit');
                    createPopup(processedBlock.x, processedBlock.y, `-${HEALTH_LOSS_ON_BOMB_HIT} Health!`, 'red');
                    processedBlock.isSlicing = true; 
                    if (hiHatSynth && typeof Tone !== 'undefined' && Tone.context.state === 'running') hiHatSynth.triggerAttackRelease("16n", Tone.now() + 0.002); 
                    console.log("BOMB HIT: Health reduced by " + HEALTH_LOSS_ON_BOMB_HIT + ". Current health: " + health);
                } else { 
                    processedBlock.state = 'hit'; 
                    const timeDiff = Math.abs(currentTime - processedBlock.hitTime);
                    const accuracyPercentage = clamp((1 - (timeDiff / (HIT_PRECISION_WINDOW / 2))) * 100, 0, 100);

                    totalNotesHit++;
                    totalAccuracySum += accuracyPercentage;
                    updateAccuracyDisplay();

                    const pointsGained = MIN_ACCURACY_POINTS_PER_NOTE +
                                         (MAX_ACCURACY_POINTS_PER_NOTE - MIN_ACCURACY_POINTS_PER_NOTE) * (accuracyPercentage / 100);
                    score += Math.round(pointsGained);
                    updateScoreDisplay();

                    health = clamp(health + HEALTH_REGEN_PER_HIT, 0, MAX_HEALTH);
                    updateHealthBar();

                    incrementCombo();
                    createParticles(processedBlock.x, processedBlock.y, processedBlock.type);
                    createPopup(processedBlock.x, processedBlock.y, `+${Math.round(pointsGained)} (${accuracyPercentage.toFixed(0)}%)`, blockColors[processedBlock.type]);
                    processedBlock.isSlicing = true; 
                    if (kickSynth && typeof Tone !== 'undefined' && Tone.context.state === 'running') kickSynth.triggerAttackRelease("C2", "0.1", Tone.now() + 0.003); 
                    console.log("NOTE HIT: Health increased by " + HEALTH_REGEN_PER_HIT + ", combo incremented to " + combo + ". Current health: " + health);
                }
            }

            if (!hitOccurredForThisKeyPress && Object.values(keybinds).includes(keyPressed)) {
                health -= HEALTH_LOSS_PER_MISS;
                updateHealthBar();
                resetCombo(); 
                createParticles(CANVAS_WIDTH / 2, TARGET_Y, 'miss'); 
                if (hiHatSynth && typeof Tone !== 'undefined' && Tone.context.state === 'running') hiHatSynth.triggerAttackRelease("16n", Tone.now() + 0.004); 
                console.log("GENERAL MISS (Pressed key '" + keyPressed + "' for no target/wrong lane): Health reduced by " + HEALTH_LOSS_PER_MISS + ", combo reset. Current health: " + health);
            }
        }

        // Create particles for visual effects
        function createParticles(x, y, type) {
            const color = type === 'left' ? blockColors['left'] :
                          type === 'right' ? blockColors['right'] :
                          type === 'miss' ? '#ff0000' : 
                          type === 'health_gain' ? '#00ff00' : 
                          type === 'bomb_hit' ? '#ff4500' : 
                          '#ffffff'; 
            for (let i = 0; i < PARTICLE_COUNT_ON_HIT; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: Math.random() * 5 + 2,
                    color: color,
                    opacity: 1,
                    life: PARTICLE_LIFETIME
                });
            }
        }

        // Update and remove particles
        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= deltaTime;
                p.opacity = clamp(p.life / PARTICLE_LIFETIME, 0, 1); 
                p.radius = clamp(p.radius * (p.life / PARTICLE_LIFETIME), 0.5, 10); 

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        // Create a floating score/accuracy popup
        function createPopup(x, y, text, color) {
            popups.push({
                x: x,
                y: y,
                text: text,
                color: color,
                opacity: 1,
                life: POPUP_LIFETIME
            });
        }

        // Update and remove popups
        function updatePopups(deltaTime) {
            for (let i = popups.length - 1; i >= 0; i--) {
                const popup = popups[i];
                popup.y -= POPUP_MOVE_SPEED * deltaTime;
                popup.life -= deltaTime;
                popup.opacity = clamp(popup.life / POPUP_LIFETIME, 0, 1);

                if (popup.life <= 0) {
                    popups.splice(i, 1);
                }
            }
        }


        // --- Drawing Functions ---

        // Draw game elements
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw pulsating target line
            const pulseFactor = Math.sin(performance.now() / 200) * 0.1 + 1;
            const gradientLine = ctx.createLinearGradient(0, 0, CANVAS_WIDTH, 0);
            gradientLine.addColorStop(0, `rgba(0, 255, 255, ${0.3 * pulseFactor})`);
            gradientLine.addColorStop(0.5, `rgba(255, 0, 255, ${0.8 * pulseFactor})`);
            gradientLine.addColorStop(1, `rgba(0, 255, 255, ${0.3 * pulseFactor})`);
            ctx.strokeStyle = gradientLine;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, TARGET_Y);
            ctx.lineTo(CANVAS_WIDTH, TARGET_Y);
            ctx.stroke();

            // Store drawn double notes to prevent drawing cable twice
            const drawnDoubleNotes = new Set();

            // Draw blocks and cables
            blocks.forEach(block => {
                // If it's a double note and we haven't drawn its cable yet
                if (block.isDouble && block.doubleId !== undefined && !drawnDoubleNotes.has(block.doubleId)) {
                    // Find the other part of the double note that is still incoming
                    const pairedBlock = blocks.find(b => b.doubleId === block.doubleId && b !== block && b.state === 'incoming');
                    if (pairedBlock && !block.isSlicing) { 
                        const startX = block.x;
                        const startY = block.y;
                        const endX = pairedBlock.x;
                        const endY = pairedBlock.y; 

                        ctx.save();
                        const cableGradient = ctx.createLinearGradient(startX, startY, endX, endY);
                        cableGradient.addColorStop(0, blockColors['left']);
                        cableGradient.addColorStop(1, blockColors['right']);
                        ctx.strokeStyle = cableGradient;
                        ctx.lineWidth = CABLE_WIDTH;
                        ctx.lineCap = 'round'; 
                        ctx.globalAlpha = block.opacity; 
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                        ctx.restore();

                        drawnDoubleNotes.add(block.doubleId); 
                    }
                }

                ctx.save();
                ctx.translate(block.x, block.y); 

                const halfSize = block.size / 2;
                const radius = halfSize * 0.2; 

                const gradient = ctx.createLinearGradient(-halfSize, -halfSize, halfSize, halfSize);
                let blockColor;
                blockColor = blockColors[block.type];

                gradient.addColorStop(0, `${blockColor}80`);
                gradient.addColorStop(0.5, blockColor);
                gradient.addColorStop(1, `${blockColor}80`);

                ctx.fillStyle = gradient;
                ctx.shadowColor = blockColor;
                ctx.shadowBlur = block.size * 0.3;

                ctx.globalAlpha = block.opacity; 

                roundRect(ctx, -halfSize, -halfSize, block.size, block.size, radius);
                ctx.fill();

                if (block.isBomb) {
                    ctx.save();
                    ctx.lineWidth = 5; 
                    const crossColor = block.type === 'left' ? blockColors['right'] : blockColors['left'];
                    ctx.strokeStyle = crossColor;
                    ctx.lineCap = 'round'; 
                    ctx.shadowColor = crossColor;
                    ctx.shadowBlur = 10;
                    ctx.globalAlpha = block.bombProgress * block.opacity; 

                    const xOffset = halfSize * 0.6; 
                    const yOffset = halfSize * 0.6;

                    ctx.beginPath();
                    ctx.moveTo(-xOffset, -yOffset);
                    ctx.lineTo(xOffset, yOffset);
                    ctx.moveTo(xOffset, -yOffset);
                    ctx.lineTo(-xOffset, yOffset);
                    ctx.stroke();
                    ctx.restore();
                }

                ctx.globalAlpha = 1; 
                ctx.restore();
            });

            // Draw particles
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.opacity;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1; 
            });

            // Draw popups
            popups.forEach(popup => {
                ctx.save();
                ctx.globalAlpha = popup.opacity;
                ctx.fillStyle = popup.color;
                ctx.font = 'bold 20px Inter';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 5;
                ctx.fillText(popup.text, popup.x, popup.y);
                ctx.restore();
            });
        }

        // Main game loop
        let lastTime = 0;
        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            if (gameActive) {
                if (currentTime - lastBlockSpawnTime > blockSpawnInterval) {
                    spawnBlock(currentTime);
                    lastBlockSpawnTime = currentTime;
                    blockSpawnInterval = Math.max(300, blockSpawnInterval - 2);
                }

                updateBlocks(deltaTime, currentTime);
                updateParticles(deltaTime);
                updatePopups(deltaTime); 
                draw();
            }

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- Leaderboard Functions ---
        function loadLeaderboard() {
            const savedScores = localStorage.getItem('rhythmSlicerLeaderboard');
            return savedScores ? JSON.parse(savedScores) : [];
        }

        function saveScore(score, accuracy) {
            if (gameOverHandled) { 
                return;
            }

            const leaderboard = loadLeaderboard();
            const newEntry = {
                score: score,
                accuracy: parseFloat(accuracy.toFixed(2)),
                date: new Date().toLocaleString()
            };
            leaderboard.push(newEntry);
            leaderboard.sort((a, b) => {
                if (b.score !== a.score) return b.score - a.score;
                if (b.accuracy !== a.accuracy) return b.accuracy - a.accuracy;
                return new Date(b.date).getTime() - new Date(a.date).getTime();
            });
            const topScores = leaderboard.slice(0, 10);
            localStorage.setItem('rhythmSlicerLeaderboard', JSON.stringify(topScores));
            console.log("Score saved:", newEntry);
        }

        function displayLeaderboard() {
            const leaderboard = loadLeaderboard();
            leaderboardList.innerHTML = ''; 

            if (leaderboard.length === 0) {
                leaderboardList.innerHTML = '<p class="text-center text-gray-400">No scores yet! Play a game to get on the leaderboard.</p>';
                return;
            }

            leaderboard.forEach((entry, index) => {
                const entryDiv = document.createElement('div');
                entryDiv.classList.add('leaderboard-entry');
                if (index < 3) { 
                    entryDiv.style.animation = `pulse 2s infinite alternate ease-in-out ${index * 0.2}s`;
                }


                entryDiv.innerHTML = `
                    <span>${index + 1}. Score: ${entry.score}</span>
                    <span>Acc: ${entry.accuracy}%</span>
                `;
                leaderboardList.appendChild(entryDiv);
            });
        }


        // --- Event Listeners ---
        window.addEventListener('load', () => {
            initCanvas();
            startScreen.style.display = 'flex';

            // Load saved settings
            const savedKeybinds = JSON.parse(localStorage.getItem('keybinds'));
            if (savedKeybinds) keybinds = savedKeybinds;
            const savedColors = JSON.parse(localStorage.getItem('blockColors'));
            if (savedColors) blockColors = savedColors;
            const savedNJS = localStorage.getItem('noteJumpSpeed');
            if (savedNJS) noteJumpSpeed = parseFloat(savedNJS);
            const savedMusicUrl = localStorage.getItem('musicUrl');
            if (savedMusicUrl) musicUrlInput.value = savedMusicUrl;

            // Update UI with loaded settings
            leftKeyDisplay.textContent = keybinds['left'].toUpperCase();
            rightKeyDisplay.textContent = keybinds['right'].toUpperCase();
            leftColorPicker.value = blockColors['left'];
            rightColorPicker.value = blockColors['right'];
            njsInput.value = noteJumpSpeed;
            if (musicUrlInput.value) {
                backgroundMusic.src = musicUrlInput.value;
            }

            // Initially show controls section
            showSettingsSection('controls');
            displayLeaderboard(); 
        });

        startGameBtn.addEventListener('click', () => {
            if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                Tone.start().then(() => {
                    console.log("Tone.js AudioContext started successfully.");
                    setupAudioSynths(); 
                    resetGame();
                }).catch(e => {
                    console.error("Error starting Tone.js AudioContext:", e);
                    resetGame();
                });
            } else {
                setupAudioSynths(); 
                resetGame();
            }
        });
        restartGameBtn.addEventListener('click', () => {
            if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                Tone.start().then(() => {
                    console.log("Tone.js AudioContext started successfully on restart.");
                    setupAudioSynths(); 
                    resetGame();
                }).catch(e => {
                    console.error("Error starting Tone.js AudioContext on restart:", e);
                    resetGame();
                });
            } else {
                setupAudioSynths(); 
                resetGame();
            }
        });

        // Global key tracking
        document.addEventListener('keydown', (event) => {
            keysPressed[event.key.toLowerCase()] = true;
            if (!awaitingKeybind && settingsModal.style.display === 'flex') {
                if (event.key === 'Escape') {
                    closeSettingsModal();
                }
                return; 
            }
            if (!awaitingKeybind) { 
                handleKeyPress(event);
            }
        });
        document.addEventListener('keyup', (event) => {
            keysPressed[event.key.toLowerCase()] = false;
        });


        // Settings Modal Handlers
        settingsBtn.addEventListener('click', () => {
            gameWasActiveBeforeSettings = gameActive; 
            gameActive = false; 
            cancelAnimationFrame(animationFrameId); 
            backgroundMusic.pause(); 

            settingsModal.style.display = 'flex';
            leftKeyDisplay.textContent = keybinds['left'].toUpperCase();
            rightKeyDisplay.textContent = keybinds['right'].toUpperCase();
            leftColorPicker.value = blockColors['left'];
            rightColorPicker.value = blockColors['right'];
            njsInput.value = noteJumpSpeed;
            musicUrlInput.value = backgroundMusic.src;
        });

        closeSettingsBtn.addEventListener('click', closeSettingsModal);

        // Function to close settings modal
        function closeSettingsModal() {
            settingsModal.style.display = 'none';
            if (gameWasActiveBeforeSettings) {
                gameActive = true; 
                gameLoop(performance.now()); 
                if (backgroundMusic.src && !backgroundMusic.paused) {
                     backgroundMusic.play().catch(e => console.error("Error resuming music:", e));
                }
            } else if (startScreen.style.display === 'flex' && !gameActive) {
            } else if (gameOverScreen.style.display === 'flex' && !gameActive) {
            }
        }


        leftKeyDisplay.addEventListener('click', () => {
            leftKeyDisplay.textContent = 'Press a key...';
            awaitingKeybind = 'left';
        });

        rightKeyDisplay.addEventListener('click', () => {
            rightKeyDisplay.textContent = 'Press a key...';
            awaitingKeybind = 'right';
        });

        // Event listener for remapping keys
        document.addEventListener('keydown', (event) => {
            if (awaitingKeybind) {
                const newKey = event.key.toLowerCase();
                if ((newKey === keybinds['left'] && awaitingKeybind !== 'left') ||
                    (newKey === keybinds['right'] && awaitingKeybind !== 'right') ||
                    ['escape', 'tab', 'shift', 'control', 'alt', 'meta'].includes(newKey)) {
                    if (awaitingKeybind === 'left') {
                        leftKeyDisplay.textContent = keybinds['left'].toUpperCase();
                    } else {
                        rightKeyDisplay.textContent = keybinds['right'].toUpperCase();
                    }
                    awaitingKeybind = null; 
                    event.preventDefault(); 
                    return;
                }

                keybinds[awaitingKeybind] = newKey;
                localStorage.setItem('keybinds', JSON.stringify(keybinds)); 
                if (awaitingKeybind === 'left') {
                    leftKeyDisplay.textContent = newKey.toUpperCase();
                } else {
                    rightKeyDisplay.textContent = newKey.toUpperCase();
                }
                awaitingKeybind = null; 
                event.preventDefault(); 
            }
        });

        leftColorPicker.addEventListener('input', (event) => {
            blockColors['left'] = event.target.value;
            localStorage.setItem('blockColors', JSON.stringify(blockColors)); 
        });

        rightColorPicker.addEventListener('input', (event) => {
            blockColors['right'] = event.target.value;
            localStorage.setItem('blockColors', JSON.stringify(blockColors)); 
        });

        njsInput.addEventListener('input', (event) => {
            noteJumpSpeed = parseFloat(event.target.value);
            localStorage.setItem('noteJumpSpeed', noteJumpSpeed.toString()); 
        });

        playMusicBtn.addEventListener('click', () => {
            const musicUrl = musicUrlInput.value;
            if (musicUrl) {
                backgroundMusic.src = musicUrl;
                if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                    Tone.start().then(() => {
                        console.log("Tone.js AudioContext started successfully for music.");
                        backgroundMusic.play().catch(e => console.error("Error playing music:", e));
                    }).catch(e => {
                        console.error("Error starting Tone.js AudioContext for music:", e);
                    });
                } else {
                    backgroundMusic.play().catch(e => console.error("Error playing music:", e));
                }
                localStorage.setItem('musicUrl', musicUrl); 
            } else {
                backgroundMusic.pause();
                backgroundMusic.src = '';
                localStorage.removeItem('musicUrl');
            }
        });

        // Settings Navigation Logic
        navControls.addEventListener('click', () => showSettingsSection('controls'));
        navGameplay.addEventListener('click', () => showSettingsSection('gameplay'));
        navAccount.addEventListener('click', () => showSettingsSection('account')); 

        function showSettingsSection(sectionName) {
            sectionControls.classList.remove('active');
            sectionGameplay.classList.remove('active');
            sectionAccount.classList.remove('active'); 
            navControls.classList.remove('active');
            navGameplay.classList.remove('active');
            navAccount.classList.remove('active'); 

            if (sectionName === 'controls') {
                sectionControls.classList.add('active');
                navControls.classList.add('active');
            } else if (sectionName === 'gameplay') {
                sectionGameplay.classList.add('active');
                navGameplay.classList.add('active');
            } else if (sectionName === 'account') { 
                sectionAccount.classList.add('active');
                navAccount.classList.add('active');
            }
        }

        // Handle Login button click
        loginBtn.addEventListener('click', () => {
            window.open('auth.html', '_blank', 'width=600,height=700,resizable=yes,scrollbars=yes');
        });

    </script>
</body>
</html>
